set hidden
set info size
set dircounts
set icons
set previewer ~/.vim/config/lf-preview.sh

map zh
map zr
map zn
map zs
map zt
map za
map z z

map sh set hedden!
map sr set reverse!
map sis set info size
map sit set info time
map sia set info size:time
map se :set sortby ext; set info size
map sn :set sortby natural; set info size

map m
map mm mark-save
map mM mark-remove
map me edit-selected
map mp paste-symlink
map mP paste-symlink-absolute-path
map mr vidir-bulk-rename
map mR lf-bulk-rename
map ms selected-dir-size
map mS cwd-size
map mc edit-config
map md5 md5

map v :toggle; down
map V invert
map x delete
map D delete
map r reload
map R rename
map ~ cd
map , find-next
map ; find-prev
map H push <c-u>
map L push <c-d>
map K push hkl
map J push hjl
map `` push ''
map c :clear; unselect
map gs !clear && git status
map gr cd-git-root
map gl follow-symlink
map t locate-file
map <c-p> locate-git-file
map <c-o> $lazygit
map <tab> locate-file-cwd
map i $~/.vim/config/lf-preview.sh "$f" | bat --color=always --style='numbers,changes' --theme=OneHalfDark --paging=always
map I $$PAGER "$f"

cmap <up> cmd-history-prev
cmap <down> cmd-history-next

cmd mkdir %mkdir -p "$@"
cmd touch %touch "$@"
cmd chmod %chmod "$@" "$f"
cmd chmod? %stat --printf "%a %n \n" "$f"
cmd vim !$EDITOR "$@"
cmd rg !clear && rg "$@"
cmd code %code .
cmd tail $tail -n 100 -f "$f"
cmd file !file "$f"
cmd pwd %echo "$f"
cmd size !du -h --max-depth=1 | sort -hr
cmd gdu $[ -x $HOME/.zinit/polaris/bin/gdu ] && $HOME/.zinit/polaris/bin/gdu || $HOME/.vim/bin/gdu
cmd md5 !md5sum "$f"
cmd selected-dir-size %du -h --max-depth=0 "$f"
cmd cwd-size %du -h --max-depth=0 .
cmd edit-config ${{ $EDITOR ~/.vim/config/lfrc }}
cmd edit-selected ${{ echo "$fx" | xargs -d '\n' $EDITOR }}
cmd vidir-bulk-rename ${{ printf "%s\n" $fx | vidir - }}
cmd cd-git-root %{{ lf -remote "send $id cd \"$(git rev-parse --show-toplevel || echo '.')\"" }}

cmd follow-symlink ${{
  res=$(readlink -f $f || echo '.')
  if [ -f "$res" ]; then
    lf -remote "send $id select \"$res\""
  elif [ -d "$res" ]; then
    lf -remote "send $id cd \"$res\""
  fi
}}

cmd locate-file-cwd ${{
  res="$(ls -1A 2> /dev/null | fzf --bind 'tab:down,btab:up')"
  if [ -f "$res" ]; then
    lf -remote "send $id select \"$res\""
  elif [ -d "$res" ]; then
    lf -remote "send $id cd \"$res\""
  fi
}}

cmd locate-file ${{
  res="$(rg --files | fzf --bind 'tab:down,btab:up')"
  if [ -f "$res" ]; then
    lf -remote "send $id select \"$res\""
  elif [ -d "$res" ]; then
    lf -remote "send $id cd \"$res\""
  fi
}}

cmd locate-git-file ${{
  git_repo="$(git rev-parse --is-inside-work-tree 2>/dev/null)"
  if [ "$git_repo" ]; then
    res="$(git ls-files $(git rev-parse --show-toplevel) | fzf --bind 'tab:down,btab:up')"
  else
    res="$(rg --files | fzf --bind 'tab:down,btab:up')"
  fi
  if [ -f "$res" ]; then
    lf -remote "send $id select \"$res\""
  elif [ -d "$res" ]; then
    lf -remote "send $id cd \"$res\""
  fi
}}

cmd z ${{
  res="$(awk -F '|' '{print $1}' ~/.z | fzf)"
  lf -remote "send $id cd \"$res\""
}}

cmd paste-symlink %{{
  load=$(cat ~/.local/share/lf/files)
  mode=$(echo "$load" | sed -n '1p')
  list=$(echo "$load" | sed '1d')
  if [ $mode = 'copy' ] || [ $mode = 'move' ]; then
    ln='ln -sr' && [ $mode = 'move' ] && ln='ln'
    please='' && [ ! -w . ] && please='sudo'
    for f in $list
    do
      $please $ln "$f" "$(pwd)/$(basename $f)"
    done
    lf -remote 'send clear'
    lf -remote 'send load'
  fi
}}

cmd paste-symlink-absolute-path %{{
  load=$(cat ~/.local/share/lf/files)
  mode=$(echo "$load" | sed -n '1p')
  list=$(echo "$load" | sed '1d')
  if [ $mode = 'copy' ] || [ $mode = 'move' ]; then
    ln='ln -s' && [ $mode = 'move' ] && ln='ln'
    please='' && [ ! -w . ] && please='sudo'
    for f in $list
    do
      $please $ln "$f" "$(pwd)/$(basename $f)"
    done
    lf -remote 'send clear'
    lf -remote 'send load'
  fi
}}

cmd x ${{
  set -f
  filename="$(basename "$f")"
  if [ -f "$filename" ] ; then
    case "$filename" in
      *.tar.bz2)   tar xvjf "$filename"    ;;
      *.tar.xz)    tar xvJf "$filename"    ;;
      *.tar.gz)    tar xvzf "$filename"    ;;
      *.bz2)       bunzip2 "$filename"     ;;
      *.rar)       unrar x "$filename"     ;;
      *.gz)        gunzip "$filename"      ;;
      *.tar)       tar xvf "$filename"     ;;
      *.tbz2)      tar xvjf "$filename"    ;;
      *.tgz)       tar xvzf "$filename"    ;;
      *.zip)       unzip "$filename"       ;;
      *.Z)         uncompress "$filename"  ;;
      *.7z)        7z x "$filename"        ;;
      *)           echo "Unable to extract '$filename'" ;;
    esac
  else
    tar cvf "$filename.tar" "$filename"
  fi
}}

cmd lf-bulk-rename ${{
  case $1 in
    # do not query extensions for renaming
    -n) mode="no-exts" ;;
    # only rename extensions
    -e) mode="only-exts" ;;
    # rename entire filepaths
    -A) mode="all-path" ;;
    # else, just rename filenames
  esac
  # make tmp files
  oldnames=$(mktemp /tmp/lf-bulk-oldnames.XXXXXXXXXX)
  newnames=$(mktemp /tmp/lf-bulk-newnames.XXXXXXXXXX)
  if [ "$mode" != "all-path" ]
  then
    dirnames=$(mktemp /tmp/lf-bulk-dirnames.XXXXXXXXXX)
    aux=$(mktemp /tmp/lf-bulk-aux.XXXXXXXXXX)
  fi
  # query selected files or all files in directory
  if [ -n "$fs" ]
  then
    index="$fs"
  else
    index="$(ls $(dirname "$f"))"
  fi
  # separate and save useful variables in files
  for path in $index
  do
    dir="$(dirname "$path")"
    fullfilename=$(basename -- "$path")
    filename="${fullfilename%.*}"  # must be here
    ext="" && [ $(echo $fullfilename | grep "\." 2>/dev/null) ] && ext="${fullfilename##*.}"
    case "$mode" in
      "all-path") echo "$(realpath "$path")" >> $oldnames ;;
      "no-exts")
        echo "$filename" >> $oldnames
        [ "$ext" != "" ] && ext=".$ext"
        echo "$ext" >> $aux
        ;;
      "only-exts")
        echo "$ext" >> $oldnames
        echo $filename >> $aux
        ;;
      "") echo "$fullfilename" >> $oldnames ;;
    esac
    [ "$mode" != "all-path" ] && echo "$dir" >> $dirnames
  done
  cp $oldnames $newnames
  # interact with user
  $EDITOR $newnames
  # run mv on each path if they were modified
  n=$(cat $oldnames | wc -l)
  if [ $(cat $newnames | wc -l) -eq $n ]
  then
    counter=1
    while [ $counter -le $((n+1)) ]
    do
      case $mode in
        "no-exts")
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          ext="$(cat $aux      | sed "${counter}q;d")"
          old="$dir/$old$ext" ; new="$dir/$new$ext"
        ;;
        "all-path")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
        ;;
        "only-exts")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          filename="$(cat $aux | sed "${counter}q;d")"
          echo $old $new
          [ "$old" != "" ] && old=".$old"
          [ "$new" != "" ] && new=".$new"
          old="$dir/$filename$old"
          new="$dir/$filename$new"
        ;;
        *)
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          old="$dir/$old" ; new="$dir/$new"
        ;;
      esac
      counter=$(($counter+1))
      [ "$old" = "$new" ] && continue
      [ -e "$new" ] && echo "File exists: $b" && continue
      # check write permission
      please=''
      for path in $old $new
      do
        [ ! -w $(dirname "$path") ] && please='sudo' && break
      done
      $please mv "$old" "$new"
      lf -remote "send $id unselect"
    done
  else
    echo "Number of filenames differ."
  fi
  # removing tmp files
  rm $oldnames $newnames
  if [ "$mode" != "all-path" ]
  then
    rm $dirnames
    rm $aux
  fi
}}

