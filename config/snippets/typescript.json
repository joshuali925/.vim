{
  "UseRef": {
    "prefix": "useRef",
    "body": ["const ref = useRef<${0:HTMLInputElement}>(null);"]
  },
  "UseState": {
    "prefix": "useState",
    "body": [
      "const [${1:state}, set${1/(.*)/${1:/capitalize}/}] = useState($0);"
    ]
  },
  "UseEffect": {
    "prefix": "useEffect",
    "body": ["useEffect(() => {", "\t$0", "}, []);"]
  },
  "UseMemo": {
    "prefix": "useMemo",
    "body": [
      "const ${1:memorized} = useMemo(() => {",
      "\treturn $2",
      "}, [$0]);"
    ]
  },
  "UseContext": {
    "prefix": "useContext",
    "body": [
      "const ${1:service}Context = useContext(${1/(.*)/${1:/capitalize}/}Context)${2:!};$0"
    ]
  },
  "Props": {
    "prefix": "props",
    "body": "$0={$0}"
  },
  "Props get set type": {
    "prefix": "props-getter-setter",
    "body": [
      "${1:state}: ${0:string};",
      "set${1/(.*)/${1:/capitalize}/}: React.Dispatch<React.SetStateAction<$0>>;"
    ]
  },
  "Filter not undefined": {
    "prefix": ".defined",
    "body": [
      ".filter(<T,>(v: T | null | undefined): v is T => v !== null && v !== undefined)"
    ]
  },
  "UseFetchResources": {
    "prefix": "template-use-fetch-resources",
    "body": [
      "import { Reducer, useEffect, useReducer, useState } from \"react\";",
      "",
      "interface State<T> {",
      "\tdata?: T;",
      "\tloading: boolean;",
      "\terror?: Error;",
      "}",
      "",
      "type Action<T> =",
      "\t| { type: \"request\" }",
      "\t| { type: \"success\"; payload: State<T>[\"data\"] }",
      "\t| { type: \"failure\"; error: NonNullable<State<T>[\"error\"]> };",
      "",
      "type GenericReducer<T = any> = Reducer<State<T>, Action<T>>;",
      "const genericReducer: GenericReducer = (state, action) => {",
      "\tswitch (action.type) {",
      "\t\tcase \"request\":",
      "\t\t\treturn { loading: true };",
      "\t\tcase \"success\":",
      "\t\t\treturn { loading: false, data: action.payload };",
      "\t\tcase \"failure\":",
      "\t\t\treturn { loading: false, error: action.error };",
      "\t\tdefault:",
      "\t\t\treturn state;",
      "\t}",
      "};",
      "",
      "export const useFetchURI = (uri: string) => {",
      "\tconst reducer: GenericReducer<${0:unknown}> = genericReducer;",
      "\tconst [state, dispatch] = useReducer(reducer, { loading: false });",
      "\tconst [refresh, setRefresh] = useState({});",
      "",
      "\tuseEffect(() => {",
      "\t\tconst abortController = new AbortController();",
      "\t\tdispatch({ type: \"request\" });",
      "\t\tfetch(uri, { signal: abortController.signal })",
      "\t\t\t.then((payload) => dispatch({ type: \"success\", payload }))",
      "\t\t\t.catch((error) => dispatch({ type: \"failure\", error }));",
      "",
      "\t\treturn () => abortController.abort();",
      "\t}, [uri, refresh]);",
      "",
      "\treturn { ...state, refresh: () => setRefresh({}) };",
      "};"
    ]
  },
  "Typed object functions": {
    "prefix": "template-typed-object-fn",
    "body": [
      "/**",
      " * Unsafe functions that assume object does not contain additional keys and",
      " * cast result based on object type.",
      " * Taken from https://news.ycombinator.com/item?id=36457557#36459276.",
      " */",
      "export const ObjectTypedFn = {",
      "\tkeys: Object.keys as <T>(obj: T) => Array<keyof T>,",
      "\tentries: Object.entries as <T>(o: T) => Array<",
      "\t\t{",
      "\t\t\t[K in Exclude<keyof T, undefined>]: [K, T[K]];",
      "\t\t}[Exclude<keyof T, undefined>]",
      "\t>,",
      "};"
    ]
  }
}
