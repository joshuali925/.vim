{
  "Log": {
    "prefix": "cl",
    "body": ["console.log('DEBUGGING ❗$0:', $0)"]
  },
  "Log stringify": {
    "prefix": "cls",
    "body": ["console.log('DEBUGGING ❗$0:\\n' + JSON.stringify($0, null, 2));"]
  },
  "Logger": {
    "prefix": "logger",
    "body": [
      "const log = (...args) => console.log(`[\\${new Date().toISOString()}]`, ...args);"
    ]
  },
  "Benchmark": {
    "prefix": "benchmark",
    "body": [
      "console.time('${1:Performance test}');",
      "$0",
      "console.timeEnd('${1:Performance test}');"
    ]
  },
  "Range": {
    "prefix": "range",
    "body": ["[...Array(${1:10}).keys()]$0"]
  },
  "Random string": {
    "prefix": "random-string",
    "body": [
      "const randString = () => Math.random().toString(36).substring(2);"
    ]
  },
  "Random integer": {
    "prefix": "random-int",
    "body": [
      "const randint = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);"
    ]
  },
  "Empty arrow function": {
    "prefix": "arrow",
    "body": ["() => { }"]
  },
  "Timeout": {
    "prefix": "timeout",
    "body": [
      "const timeout = (ms) => {",
      "\treturn new Promise((resolve) => setTimeout(resolve, ms));",
      "}"
    ]
  },
  "Timeout outside async": {
    "prefix": "sleep",
    "body": [
      "await new Promise((resolve) => setTimeout(resolve, ${1:1000}));$0"
    ]
  },
  "Immediately-invoked async function": {
    "prefix": "async",
    "body": ["(async () => {", "\t$0", "})();"]
  },
  "Promise then": {
    "prefix": "then",
    "body": [
      ".then((resp) => {",
      "\t$0",
      "})",
      ".catch((error) => {",
      "\t$0",
      "})"
    ]
  },
  "Promise then log": {
    "prefix": "then-log",
    "body": [".then((resp) => {", "\tconsole.log(resp);", "})"]
  },
  "Read from file": {
    "prefix": "read-file",
    "body": [
      "const fs = require('fs');",
      "const lines = fs.readFileSync(`\\${__dirname}/${1:fileName}`, 'utf8')",
      "\t.split(/\\r?\\n/)",
      "\t.filter(line => line.trim() !== '');"
    ]
  },
  "Write to file": {
    "prefix": "write-file",
    "body": [
      "const fs = require('fs');",
      "fs.mkdirSync(`\\${__dirname}/`, { recursive: true });",
      "fs.writeFileSync(`\\${__dirname}/${1:fileName}`, ${0:str});",
      "// fs.appendFileSync(`\\${__dirname}/${1:fileName}`, ${0:str});"
    ]
  },
  "Cypress delay": {
    "prefix": "cydelay",
    "body": ["cy.wait(delay);", "$0"]
  },
  "Cypress test id": {
    "prefix": "cytestid",
    "body": ["cy.get('[data-test-subj=\"$1\"]')$0"]
  },
  "Cypress click": {
    "prefix": "cyclick",
    "body": ["cy.contains('$0').click({ force: true });"]
  },
  "Cypress text exists": {
    "prefix": "cyexists",
    "body": ["cy.contains('$0').should('exist');"]
  },
  "REST requester": {
    "prefix": "request",
    "body": [
      "// request(url: string, { body, ...options }: RequestOptions & { body?: any } = {}): Promise<unknown>;",
      "function request(url, { body, ...options } = {}) {",
      "\treturn new Promise((resolve, reject) => {",
      "\t\tconst req = (",
      "\t\t\turl.startsWith(\"https://\") || options.protocol === \"https\"",
      "\t\t\t\t? require(\"https\")",
      "\t\t\t\t: require(\"http\")",
      "\t\t).request(url, { ...options }, (res) => {",
      "\t\t\tconst chunks = [];",
      "\t\t\tres.on(\"data\", (data) => chunks.push(data));",
      "\t\t\tres.on(\"end\", () => {",
      "\t\t\t\tlet resBody = Buffer.concat(chunks).toString();",
      "\t\t\t\tif (res.headers[\"content-type\"] === \"application/json\") {",
      "\t\t\t\t\tresBody = JSON.parse(resBody);",
      "\t\t\t\t}",
      "\t\t\t\tresolve(resBody.toString());",
      "\t\t\t});",
      "\t\t});",
      "\t\treq.on(\"error\", reject);",
      "\t\tif (body) {",
      "\t\t\treq.write(body);",
      "\t\t}",
      "\t\treq.end();",
      "\t});",
      "}",
      "",
      "function postJSON(url, obj) {",
      "\treturn request(url, {",
      "\t\tmethod: \"POST\",",
      "\t\theaders: { \"Content-Type\": \"application/obj\" },",
      "\t\tbody: obj.stringify(obj),",
      "\t});",
      "}"
    ]
  }
}
